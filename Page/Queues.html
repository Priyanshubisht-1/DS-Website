<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Website</title>
    <link rel="stylesheet" href="../CSS/ALL.css" />
  </head>
  <body>
    <header>
      <nav class="nav" id="nav">
        <img src="../Images/1000031782-removebg-preview.png" />
        <a href="../index.html">Home</a>
        <a href="DS.html">Practice</a>
        <a href="../index.html#About">About</a>
        <a href="#Contact">Contact</a>
      </nav>
    </header>

    <main>
      <section class="Sidebar">
        <span>Queues</span>

        <div>
          <p>1.</p>
          <a href="Queues.html#queue1"
            >Implement the operations of simple queue in an integer array
          </a>
        </div>
        <div>
          <p>2.</p>
          <a href="Queues.html#queue2"
            >Implement the operations of simple queue in a string array
          </a>
        </div>
        <div>
          <p>3.</p>
          <a href="Queues.html#queue3"
            >Implement the operations of queue dynamically of integers</a
          >
        </div>
        <div>
          <p>4.</p>
          <a href="Queues.html#queue4"
            >Implement the operations of queue dynamically of string</a
          >
        </div>
        <div>
          <p>5.</p>
          <a href="Queues.html#queue5"
            >Implement the operations of circular queue in an integer array</a
          >
        </div>
        <div>
          <p>6.</p>
          <a href="Queues.html#queue6"
            >Implement the operations of circular queue in a string array</a
          >
        </div>
        <div>
          <p>7.</p>
          <a href="Queues.html#queue7"
            >Implement the operations of priority queue in an integer array</a
          >
        </div>
        <div>
          <p>8.</p>
          <a href="Queues.html#queue8"
            >Implement the operations of priority queue in a string array</a
          >
        </div>
        <div>
          <p>9.</p>
          <a href="Queues.html#queue9"
            >Implement the operations of double ended queue in an integer array
          </a>
        </div>
        <div>
          <p>10.</p>
          <a href="Queues.html#queue10"
            >Implement the operations of double ended queue in a string array
          </a>
        </div>
        <div>
          <p>11.</p>
          <a href="Queues.html#queue11"
            >Implement the operations of priority queue dynamically of integers
          </a>
        </div>
        <div>
          <p>12.</p>
          <a href="Queues.html#queue12"
            >Implement the operations of priority queue dynamically of string
          </a>
        </div>
        <div>
          <p>13.</p>
          <a href="Queues.html#queue13"
            >Find the first circular tour that visits all petrol pumps.</a
          >
        </div>
        <div>
          <p>14.</p>
          <a href="Queues.html#queue14"
            >Length of the longest valid substring.</a
          >
        </div>
        <div>
          <p>15.</p>
          <a href="Queues.html#queue15">Find the next greater element.</a>
        </div>
        <div>
          <p>16.</p>
          <a href="Queues.html#queue16">Find next smaller element.</a>
        </div>
        <div>
          <p>17.</p>
          <a href="Queues.html#queue17"
            >Queue based approach for first non-repeating character in a
            stream.</a
          >
        </div>
        <div>
          <p>18.</p>
          <a href="Queues.html#queue18">Reverse first K elements of queue.</a>
        </div>
        <div>
          <p>19.</p>
          <a href="Queues.html#queue19">Queue reversal.</a>
        </div>
        <div>
          <p>20.</p>
          <a href="Queues.html#queue20">Rotten oranges.</a>
        </div>
      </section>

      <section class="Content">
        <h2>Queues</h2>
        <div id="queue1" class="Content-box">
          <h3>
            1. Implement the operations of simple queue in an integer array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct Queue
{
    int size;
    int front;
    int rear;
    int *a;
};

void create(struct Queue *q, int s)
{
    q->size = s;
    q->front = q->rear = -1;
    q->a = (int *)malloc(sizeof(int) * s);
}

void Insert(struct Queue *q, int x)
{
    if (q->rear == q->size - 1)
        printf("Queue is Full\n");
    else
        q->a[++q->rear] = x;
}

int Delete(struct Queue *q)
{
    int x = -1;
    if (q->front == q->rear)
        printf("Queue is Empty\n");
    else
        x = q->a[++q->front];
    return x;
}

int PeekFront(struct Queue q)
{
    return q.front == q.rear ? -1 : q.a[q.front + 1];
}

int PeekRear(struct Queue q)
{
    return q.front == q.rear ? -1 : q.a[q.rear];
}

int IsEmpty(struct Queue q)
{
    return q.front == q.rear ? 1 : 0;
}

int IsFull(struct Queue q)
{
    return q.rear == q.size - 1 ? 1 : 0;
}

void Display(struct Queue q)
{
    if (q.front == q.rear)
        printf("Queue is Empty\n");
    else
    {
        int i = q.front + 1;
        printf("Queue : ");
        while (i <= q.rear)
            printf("%d ", q.a[i++]);
        printf("\n");
    }
}

void Destroy(struct Queue *q)
{
    char *temp;
    int i = 0;
    q->front = q->rear = -1;
    free(q->a);
    q->a = NULL;
}

int main()
{
    struct Queue q;
    create(&q, 5);
    Insert(&q, 10);
    Insert(&q, 20);
    Insert(&q, 30);
    Insert(&q, 40);
    Insert(&q, 50);
    Display(q);

    printf("Is Queue Empty : %d\n", IsEmpty(q));
    printf("Is Queue Full : %d\n", IsFull(q));
    printf("Front value : %d\n", PeekFront(q));
    printf("Rear value : %d\n", PeekRear(q));
    printf("Deleted value : %d\n", Delete(&q));
    Display(q);

    Destroy(&q);
    Delete(&q);
    return 0;
}
        </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue : 10 20 30 40 50 
Is Queue Empty : 0
Is Queue Full : 1
Front value : 10
Rear value : 50
Deleted value : 10
Queue : 20 30 40 50
Queue is Empty
                                        </pre
              >
            </div>
          </div>
        </div>

        <div id="queue2" class="Content-box">
          <h3>
            2. Implement the operations of simple queue in a string array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

struct Queue
{
    int size;
    int front;
    int rear;
    char **a;
};

void create(struct Queue *q, int s)
{
    q->size = s;
    q->front = q->rear = -1;
    q->a = (char **)malloc(sizeof(char *) * s);
}

void Insert(struct Queue *q, char *x, int l)
{
    if (q->rear == q->size - 1)
        printf("Queue is Full\n");
    else
    {
        int i = 0;
        char *temp = (char *)malloc(sizeof(char) * (l + 1));
        while (x[i] != '\0' && i < l)
            temp[i] = x[i++];
        temp[i] = '\0';
        q->a[++q->rear] = temp;
    }
}

void Delete(struct Queue *q)
{
    char *temp;
    if (q->front == q->rear)
        printf("Queue is Empty\n");
    else
    {
        temp = q->a[++q->front];
        printf("Deleted value : %s\n", temp);
        free(temp);
    }
}

char *PeekFront(struct Queue q)
{
    return q.front == q.rear ? NULL : q.a[q.front + 1];
}

char *PeekRear(struct Queue q)
{
    return q.front == q.rear ? NULL : q.a[q.rear];
}

int IsEmpty(struct Queue q)
{
    return q.front == q.rear ? 1 : 0;
}

int IsFull(struct Queue q)
{
    return q.rear == q.size - 1 ? 1 : 0;
}

void Display(struct Queue q)
{
    if (q.front == q.rear)
        printf("Queue is Empty\n");
    else
    {
        int i = q.front + 1;
        printf("Queue : ");
        while (i <= q.rear)
            printf("%s ", q.a[i++]);
        printf("\n");
    }
}

void Destroy(struct Queue *q)
{
    char *temp;
    int i = 0;
    while (i < q->size)
    {
        temp = q->a[++q->front];
        free(temp);
        i++;
    }
    q->front = q->rear = -1;
    free(q->a);
    q->a = NULL;
}

int main()
{
    struct Queue q;
    create(&q, 5);
    Insert(&q, "Hello", strlen("Hello"));
    Insert(&q, "my", strlen("my"));
    Insert(&q, "name", strlen("name"));
    Insert(&q, "is", strlen("is"));
    Insert(&q, "you", strlen("you"));
    Display(q);

    printf("Is Queue Empty : %d\n", IsEmpty(q));
    printf("Is Queue Full : %d\n", IsFull(q));
    printf("Front value : %s\n", PeekFront(q));
    printf("Rear value : %s\n", PeekRear(q));
    Delete(&q);
    Display(q);

    Destroy(&q);
    Delete(&q);
    return 0;
}
        </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue : Hello my name is you 
Is Queue Empty : 0
Is Queue Full : 1
Front value : Hello
Rear value : you
Deleted value : Hello
Queue : my name is you
Queue is Empty
                                        </pre
              >
            </div>
          </div>
        </div>

        <div id="queue3" class="Content-box">
          <h3>
            3. Implement the operations of queue dynamically of integers
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct Node
{
    int data;
    struct Node *next;
};

struct Queue
{
    struct Node *front;
    struct Node *rear;
};

void Insert(struct Queue *q, int x)
{
    struct Node *t = (struct Node *)malloc(sizeof(struct Node));
    if (t == NULL)
        printf("Queue is Full\n");
    else
    {
        t->data = x;
        t->next = NULL;
        if (q->front == NULL)
            q->front = t;
        else
            q->rear->next = t;
        q->rear = t;
    }
}

int Delete(struct Queue *q)
{
    int x = -1;
    struct Node *t;
    if (q->front == NULL)
        printf("Queue is Empty\n");
    else
    {
        t = q->front;
        q->front = t->next;
        x = t->data;
        free(t);
    }
    return x;
}

int PeekFront(struct Queue q)
{
    return q.front == NULL ? -1 : (q.front)->data;
}

int PeekRear(struct Queue q)
{
    return q.front == NULL ? -1 : (q.rear)->data;
}

int IsEmpty(struct Queue q)
{
    return q.front == NULL ? 1 : 0;
}

int IsFull(struct Queue q)
{
    struct Node *t = (struct Node *)malloc(sizeof(struct Node));
    return t == NULL ? 1 : 0;
}

void Display(struct Queue q)
{
    if (q.front == NULL)
        printf("Queue is Empty\n");
    else
    {
        struct Node *p = q.front;
        printf("Queue : ");
        while (p != NULL)
        {
            printf("%d ", p->data);
            p = p->next;
        }
        printf("\n");
    }
}

void Destroy(struct Queue *q)
{
    struct Node *t1, *t2 = q->front;
    while (t2 != NULL)
    {
        t1 = t2;
        t2 = t2->next;
        free(t1);
    }
    free(t1);
    q->front = q->rear = NULL;
}

int main()
{
    struct Queue q;
    q.front = q.rear = NULL;
    Insert(&q, 10);
    Insert(&q, 20);
    Insert(&q, 30);
    Insert(&q, 40);
    Insert(&q, 50);
    Display(q);

    printf("Is Queue Empty : %d\n", IsEmpty(q));
    printf("Is Queue Full : %d\n", IsFull(q));
    printf("Front value : %d\n", PeekFront(q));
    printf("Rear value : %d\n", PeekRear(q));
    printf("Deleted value : %d\n", Delete(&q));
    Display(q);

    Destroy(&q);
    Delete(&q);
    return 0;
}
        </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue : 10 20 30 40 50 
Is Queue Empty : 0
Is Queue Full : 0
Front value : 10
Rear value : 50
Deleted value : 10
Queue : 20 30 40 50
Queue is Empty
                                        </pre
              >
            </div>
          </div>
        </div>

        <div id="queue4" class="Content-box">
          <h3>
            4. Implement the operations of queue dynamically of string (insert,
            delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

struct Node
{
    char *data;
    struct Node *next;
};

struct Queue
{
    struct Node *front;
    struct Node *rear;
};

void Insert(struct Queue *q, char *x, int l)
{
    struct Node *t = (struct Node *)malloc(sizeof(struct Node));
    if (t == NULL)
        printf("Queue is Full\n");
    else
    {
        int i = 0;
        char *temp = (char *)malloc(sizeof(char) * (l + 1));
        while (x[i] != '\0' && i < l)
            temp[i] = x[i++];
        temp[i] = '\0';

        t->data = temp;
        t->next = NULL;
        if (q->front == NULL)
            q->front = t;
        else
            q->rear->next = t;
        q->rear = t;
    }
}

void Delete(struct Queue *q)
{
    char *x = NULL;
    struct Node *t;
    if (q->front == NULL)
        printf("Queue is Empty\n");
    else
    {
        t = q->front;
        q->front = t->next;
        x = t->data;
        printf("Deleted value : %s\n", x);
        free(t);
        free(x);
    }
}

char *PeekFront(struct Queue q)
{
    return q.front == NULL ? NULL : (q.front)->data;
}

char *PeekRear(struct Queue q)
{
    return q.front == NULL ? NULL : (q.rear)->data;
}

int IsEmpty(struct Queue q)
{
    return q.front == NULL ? 1 : 0;
}

int IsFull(struct Queue q)
{
    struct Node *t = (struct Node *)malloc(sizeof(struct Node));
    return t == NULL ? 1 : 0;
}

void Display(struct Queue q)
{
    if (q.front == NULL)
        printf("Queue is Empty\n");
    else
    {
        struct Node *p = q.front;
        printf("Queue : ");
        while (p != NULL)
        {
            printf("%s ", p->data);
            p = p->next;
        }
        printf("\n");
    }
}

void Destroy(struct Queue *q)
{
    struct Node *t1, *t2 = q->front;
    while (t2 != NULL)
    {
        t1 = t2;
        t2 = t2->next;
        free(t1->data);
        free(t1);
    }
    free(t1->data);
    free(t1);

    q->front = q->rear = NULL;
}

int main()
{
    struct Queue q;
    q.front = q.rear = NULL;

    Insert(&q, "Hello", strlen("Hello"));
    Insert(&q, "my", strlen("my"));
    Insert(&q, "name", strlen("name"));
    Insert(&q, "is", strlen("is"));
    Insert(&q, "you", strlen("you"));
    Display(q);

    printf("Is Queue Empty : %d\n", IsEmpty(q));
    printf("Is Queue Full : %d\n", IsFull(q));
    printf("Front value : %s\n", PeekFront(q));
    printf("Rear value : %s\n", PeekRear(q));
    Delete(&q);
    Display(q);

    Destroy(&q);
    Delete(&q);
    return 0;
}

        </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue : Hello my name is you 
Is Queue Empty : 0
Is Queue Full : 0
Front value : Hello
Rear value : you
Deleted value : Hello
Queue : my name is you
Queue is Empty
                                        </pre
              >
            </div>
          </div>
        </div>

        <div id="queue5" class="Content-box">
          <h3>
            5. Implement the operations of circular queue in an integer array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct Queue
{
    int size;
    int count;
    int front;
    int rear;
    int *a;
};

void create(struct Queue *q, int s)
{
    q->size = s;
    q->count = 0;
    q->front = q->rear = 0;
    q->a = (int *)malloc(sizeof(int) * s);
}

void Insert(struct Queue *q, int x)
{
    if (q->count == q->size)
        printf("Queue is Full\n");
    else
    {
        q->rear = (q->rear + 1) % q->size;
        q->a[q->rear] = x;
        q->count++;
    }
}

int Delete(struct Queue *q)
{
    int x = -1;
    if (q->count == 0)
        printf("Queue is Empty\n");
    else
    {
        q->front = (q->front + 1) % q->size;
        x = q->a[q->front];
        q->count--;
    }
    return x;
}

int PeekFront(struct Queue q)
{
    return q.count == 0 ? -1 : q.a[(q.front + 1) % q.size];
}

int PeekRear(struct Queue q)
{
    return q.count == 0 ? -1 : q.a[q.rear];
}

int IsEmpty(struct Queue q)
{
    return q.count == 0 ? 1 : 0;
}

int IsFull(struct Queue q)
{
    return q.count == q.size ? 1 : 0;
}

void Display(struct Queue q)
{
    if (q.count == 0)
        printf("Queue is Empty\n");
    else
    {
        int i = (q.front + 1) % q.size;
        printf("Queue : ");
        do
        {
            printf("%d ", q.a[i]);
            i = (i + 1) % q.size;
        } while (i != (q.rear + 1) % q.size);
        printf("\n");
    }
}

void Destroy(struct Queue *q)
{
    char *temp;
    int i = 0;
    q->count = 0;
    q->front = q->rear = 0;
    free(q->a);
    q->a = NULL;
}

int main()
{
    struct Queue q;
    create(&q, 5);
    Insert(&q, 10);
    Insert(&q, 20);
    Insert(&q, 30);
    Insert(&q, 40);
    Insert(&q, 50);
    // Insert(&q, 60);

    Display(q);

    printf("Is Queue Empty : %d\n", IsEmpty(q));
    printf("Is Queue Full : %d\n", IsFull(q));
    printf("Front value : %d\n", PeekFront(q));
    printf("Rear value : %d\n", PeekRear(q));
    printf("Deleted value : %d\n", Delete(&q));
    printf("Front value : %d\n", PeekFront(q));
    Display(q);

    Destroy(&q);
    Delete(&q);
    return 0;
}
        </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue : 10 20 30 40 50 
Is Queue Empty : 0
Is Queue Full : 1
Front value : 10
Rear value : 50
Deleted value : 10
Front value : 20
Queue : 20 30 40 5
                                        </pre
              >
            </div>
          </div>
        </div>

        <div id="queue6" class="Content-box">
          <h3>
            6. Implement the operations of circular queue in a string array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

struct Queue
{
    int size;
    int count;
    int front;
    int rear;
    char **a;
};

void create(struct Queue *q, int s)
{
    q->size = s;
    q->count = 0;
    q->front = q->rear = 0;
    q->a = (char **)malloc(sizeof(char *) * s);
}

void Insert(struct Queue *q, char *x, int l)
{
    if (q->count == q->size)
        printf("Queue is Full\n");
    else
    {
        int i = 0;
        char *temp = (char *)malloc(sizeof(char) * (l + 1));
        while (x[i] != '\0' && i < l)
            temp[i] = x[i++];
        temp[i] = '\0';
        q->rear = (q->rear + 1) % q->size;
        q->a[q->rear] = temp;
        q->count++;
    }
}

void Delete(struct Queue *q)
{
    char *temp;
    if (q->count == 0)
        printf("Queue is Empty\n");
    else
    {
        q->front = (q->front + 1) % q->size;
        temp = q->a[q->front];
        printf("Deleted value : %s\n", temp);
        free(temp);
        q->count--;
    }
}

char *PeekFront(struct Queue q)
{
    return q.count == 0 ? NULL : q.a[(q.front + 1) % q.size];
}

char *PeekRear(struct Queue q)
{
    return q.count == 0 ? NULL : q.a[q.rear];
}

int IsEmpty(struct Queue q)
{
    return q.count == 0 ? 1 : 0;
}

int IsFull(struct Queue q)
{
    return q.count == q.size ? 1 : 0;
}

void Display(struct Queue q)
{
    if (q.count == 0)
        printf("Queue is Empty\n");
    else
    {
        int i = (q.front + 1) % q.size;
        printf("Queue : ");
        do
        {
            printf("%s ", q.a[i]);
            i = (i + 1) % q.size;

        } while (i != (q.rear + 1) % q.size);
        printf("\n");
    }
}

void Destroy(struct Queue *q)
{
    char *temp;
    int i = (q->front + 1) % q->size;
    do
    {
        temp = q->a[i];
        free(temp);
        i = (i + 1) % q->size;
    } while (i != (q->rear + 1) % q->size);
    q->count = 0;
    q->front = q->rear = 0;
    q->a = NULL;
}

int main()
{
    struct Queue q;
    create(&q, 5);
    Insert(&q, "Hello", strlen("Hello"));
    Insert(&q, "my", strlen("my"));
    Insert(&q, "name", strlen("name"));
    Insert(&q, "is", strlen("is"));
    Insert(&q, "you", strlen("you"));
    Display(q);

    printf("Is Queue Empty : %d\n", IsEmpty(q));
    printf("Is Queue Full : %d\n", IsFull(q));
    printf("Front value : %s\n", PeekFront(q));
    printf("Rear value : %s\n", PeekRear(q));
    Delete(&q);
    Display(q);

    Destroy(&q);
    Delete(&q);
    return 0;
}
              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue : Hello my name is you 
Is Queue Empty : 0
Is Queue Full : 1
Front value : Hello
Rear value : you
Deleted value : Hello
Queue : my name is you
Queue is Empty
              </pre>
            </div>
          </div>
        </div>

        <div id="queue7" class="Content-box">
          <h3>
            7. Implement the operations of priority queue in an integer array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct array
{
    int f;
    int r;
    int c;
    int *a;
};

struct PriorityQueue
{
    int np;
    int es;
    struct array *Q;
};

void create(struct PriorityQueue *q, int nump, int each)
{
    q->np = nump;
    q->es = each;
    q->Q = (struct array *)malloc(sizeof(struct array) * nump);
    for (int i = 0; i < nump; i++)
    {
        q->Q[i].f = q->Q[i].r = -1;
        q->Q[i].c = 0;
    }
}

void Insert(struct PriorityQueue *q, int x, int pr)
{
    if (pr < 0 || pr > q->np)
    {
        printf("Invalid Priority Input!\n");
        return;
    }

    if (q->Q[pr - 1].c == q->es)
        printf("Prority Queue for %d priority is Full", pr);
    else
    {
        if (q->Q[pr - 1].r == -1)
        {
            q->Q[pr - 1].f == 0;
            q->Q[pr - 1].a = (int *)malloc(sizeof(int) * q->es);
        }

        q->Q[pr - 1].r = (q->Q[pr - 1].r + 1) % q->es;
        q->Q[pr - 1].a[q->Q[pr - 1].r] = x;
        q->Q[pr - 1].c = q->Q[pr - 1].c + 1;
    }
}

int Delete(struct PriorityQueue *q)
{
    int i, x = -1;
    if (q->np == 0)
        printf("Priority Queue is Empty\n");
    else
    {
        for (i = 0; i < q->np; i++)
        {
            if (q->Q[i].c != 0)
            {
                q->Q[i].f = q->Q[i].f + 1;
                x = q->Q[i].a[q->Q[i].f];
                q->Q[i].c = q->Q[i].c - 1;
                break;
            }
        }
    }

    return x;
}

void display(struct PriorityQueue *q)
{
    for (int i = 0; i < q->np; i++)
    {
        int j = q->Q[i].f + 1;
        printf("Queue %d : ", i + 1);
        while (j != (q->Q[i].r + 1) % q->es)
        {
            printf("%d ", q->Q[i].a[j]);
            j = (j + 1) % q->es;
        }
        printf("\n");
    }
}

int main()
{
    struct PriorityQueue var;
    var.es = var.np = 0;
    create(&var, 3, 5);
    Insert(&var, 10, 1);
    Insert(&var, 20, 1);
    Insert(&var, 30, 1);
    Insert(&var, 1, 2);
    Insert(&var, 3, 2);
    Insert(&var, 5, 2);
    Insert(&var, 7, 2);
    Insert(&var, 11, 3);
    Insert(&var, 31, 3);
    Insert(&var, 51, 3);
    Insert(&var, 71, 3);

    display(&var);
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));
    printf("Deleted Value : %d\n", Delete(&var));

    return 0;
}</pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Queue 1 : 10 20 30 
Queue 2 : 1 3 5 7
Queue 3 : 11 31 51 71
Deleted Value : 10
Deleted Value : 20
Deleted Value : 30
Deleted Value : 1
Deleted Value : 3
Deleted Value : 5
Deleted Value : 7
Deleted Value : 11
Deleted Value : 31
Deleted Value : 51
Deleted Value : 71
Deleted Value : -1
Deleted Value : -1
Deleted Value : -1
Deleted Value : -1
Deleted Value : -1
</pre
              >
            </div>
          </div>
        </div>

        <div id="queue8" class="Content-box">
          <h3>
            8. Implement the operations of priority queue in a string array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;string.h>
#define SIZE 5

int insert(char queue[], int priority[], int *count, char value, int prio)
{
    if (*count == SIZE)
    {
        printf("Queue Full\n");
        return 0;
    }

    for (int j = 0; j < *count; j++)
    {
        if (priority[j] == prio)
        {
            printf("Priority %d already exists. Choose a different priority.\n", prio);
            return 0;
        }
    }

    int i;
    for (i = *count - 1; i >= 0 && priority[i] < prio; i--)
    {
        queue[i + 1] = queue[i];
        priority[i + 1] = priority[i];
    }

    queue[i + 1] = value;
    priority[i + 1] = prio;
    (*count)++;

    printf("Inserted: %c with priority %d\n", value, prio);
    return 1;
}

void delete(char queue[], int priority[], int *count)
{
    if (*count == 0)
    {
        printf("Queue Empty\n");
    }
    else
    {
        printf("Deleted: %c with priority %d\n", queue[0], 
        priority[0]);

        for (int i = 0; i < *count - 1; i++)
        {
            queue[i] = queue[i + 1];
            priority[i] = priority[i + 1];
        }
        (*count)--;
    }
}

void peek(char queue[], int priority[], int count)
{
    if (count == 0)
    {
        printf("Queue Empty\n");
    }
    else
    {
        printf("Peek: %c with priority %d\n", queue[0],
         priority[0]);
    }
}

void isEmpty(int count)
{
    printf(count == 0 ? "Queue is Empty\n" : "Queue is Not 
    Empty\n");
}

void isFull(int count)
{
    printf(count == SIZE ? "Queue is Full\n" : "Queue is Not 
    Full\n");
}

int main()
{
    char queue[SIZE];
    int priority[SIZE];
    int count = 0;

    int choice, prio;
    char value;

    while (1)
    {
        printf("\n1. INSERT\n2. DELETE\n3. PEEK\n4. ISEMPTY\n5. 
        ISFULL\n6. EXIT\nENTER THE OPERATION: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            if (count == SIZE)
            {
                printf("Queue Full\n");
                break;
            }
            printf("Enter the character: ");
            scanf(" %c", &value);
            printf("Enter the priority: ");
            scanf("%d", &prio);
            insert(queue, priority, &count, value, prio);
            break;
        case 2:
            delete (queue, priority, &count);
            break;
        case 3:
            peek(queue, priority, count);
            break;
        case 4:
            isEmpty(count);
            break;
        case 5:
            isFull(count);
            break;
        case 6:
            return 0;
        default:
            printf("Invalid option. Please try again.\n");
            break;
        }
    }
}

              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
1. INSERT
2. DELETE
3. PEEK
4. ISEMPTY
5. ISFULL
6. EXIT
ENTER THE OPERATION: 1
Enter the character: A
Enter the priority: 3
Inserted: A with priority 3

1. INSERT
2. DELETE
3. PEEK
4. ISEMPTY
5. ISFULL
6. EXIT
ENTER THE OPERATION: 1
Enter the character: B
Enter the priority: 5
Inserted: B with priority 5

1. INSERT
2. DELETE
3. PEEK
4. ISEMPTY
5. ISFULL
6. EXIT
ENTER THE OPERATION: 1
Enter the character: C
Enter the priority: 1
Inserted: C with priority 1

1. INSERT
2. DELETE
3. PEEK
4. ISEMPTY
5. ISFULL
6. EXIT
ENTER THE OPERATION: 2
Deleted: B with priority 5

              </pre>
            </div>
          </div>
        </div>

        <div id="queue9" class="Content-box">
          <h3>
            9. Implement the operations of double ended queue in an integer
            array (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct DEQueue
{
    int size;
    int front;
    int rear;
    int *a;
};

void create(struct DEQueue *q, int s)
{
    q->size = s;
    q->front = q->rear = -1;
    q->a = (int *)malloc(sizeof(int) * s);
}

void InsertFront(struct DEQueue *q, int x)
{
    if (q->front == -1)
        printf("DEQueue is Full at Start\n");
    else
        q->a[q->front--] = x;
}

void InsertRear(struct DEQueue *q, int x)
{
    if (q->rear == q->size - 1)
        printf("DEQueue is Full at End\n");
    else
        q->a[++q->rear] = x;
}

int DeleteFront(struct DEQueue *q)
{
    int x = -1;
    if (q->front == q->rear)
        printf("DEQueue is Empty\n");
    else
        x = q->a[++q->front];
    return x;
}

int DeleteRear(struct DEQueue *q)
{
    int x = -1;
    if (q->front == q->rear)
        printf("DEQueue is Empty\n");
    else
        x = q->a[q->rear--];
    return x;
}

int PeekFront(struct DEQueue q)
{
    return q.front == q.rear ? -1 : q.a[q.front + 1];
}

int PeekRear(struct DEQueue q)
{
    return q.front == q.rear ? -1 : q.a[q.rear];
}

int IsEmpty(struct DEQueue q)
{
    return q.front == q.rear ? 1 : 0;
}

int IsFull(struct DEQueue q)
{
    return q.rear == q.size - 1 && q.front == -1 ? 1 : 0;
}

void Display(struct DEQueue q)
{
    if (q.front == q.rear)
        printf("DEQueue is Empty\n");
    else
    {
        int i = q.front + 1;
        printf("DEQueue : ");
        while (i <= q.rear)
            printf("%d ", q.a[i++]);
        printf("\n");
    }
}

void Destroy(struct DEQueue *q)
{
    char *temp;
    int i = 0;
    q->front = q->rear = -1;
    free(q->a);
    q->a = NULL;
}

int main()
{
    struct DEQueue q;
    create(&q, 5);
    InsertFront(&q, 10);
    InsertFront(&q, 20);
    InsertRear(&q, 30);
    InsertRear(&q, 40);
    InsertRear(&q, 50);
    InsertRear(&q, 60);
    Display(q);

    printf("Is DEQueue Empty : %d\n", IsEmpty(q));
    printf("Is DEQueue Full : %d\n", IsFull(q));
    printf("Front value : %d\n", PeekFront(q));
    printf("Rear value : %d\n", PeekRear(q));
    printf("Deleted Front value : %d\n", DeleteFront(&q));
    printf("Deleted Rear value : %d\n", DeleteRear(&q));
    Display(q);

    // Destroy(&q);
    // DeleteRear(&q);
    return 0;
}
              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
DEQueue is Full at Start
DEQueue is Full at Start
DEQueue : 30 40 50 60
Is DEQueue Empty : 0
Is DEQueue Full : 0
Front value : 30
Rear value : 60
Deleted Front value : 30
Deleted Rear value : 60
DEQueue : 40 50
              </pre>
            </div>
          </div>
        </div>
        <div id="queue10" class="Content-box">
          <h3>
            10. Implement the operations of double ended queue in a string array
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

struct DEQueue
{
    int size;
    int front;
    int rear;
    char **a;
};

void create(struct DEQueue *q, int s)
{
    q->size = s;
    q->front = q->rear = -1;
    q->a = (char **)malloc(sizeof(char *) * s);
}

void InsertFront(struct DEQueue *q, char *x, int l)
{
    if (q->front == -1)
        printf("DEQueue is Full at Start\n");
    else
    {
        int i = 0;
        char *temp = (char *)malloc(sizeof(char) * (l + 1));
        while (x[i] != '\0' && i < l)
            temp[i] = x[i++];
        temp[i] = '\0';
        q->a[q->front--] = temp;
    }
}

void InsertRear(struct DEQueue *q, char *x, int l)
{
    if (q->rear == q->size - 1)
        printf("DEQueue is Full at Rear\n");
    else
    {
        int i = 0;
        char *temp = (char *)malloc(sizeof(char) * (l + 1));
        while (x[i] != '\0' && i < l)
            temp[i] = x[i++];
        temp[i] = '\0';
        q->a[++q->rear] = temp;
    }
}

void DeleteFront(struct DEQueue *q)
{
    char *temp;
    if (q->front == q->rear)
        printf("DEQueue is Empty\n");
    else
    {
        temp = q->a[++q->front];
        printf("Deleted Front value : %s\n", temp);
        free(temp);
    }
}

void DeleteRear(struct DEQueue *q)
{
    char *temp;
    if (q->front == q->rear)
        printf("DEQueue is Empty\n");
    else
    {
        temp = q->a[q->rear--];
        printf("Deleted Rear value : %s\n", temp);
        free(temp);
    }
}

char *PeekFront(struct DEQueue q)
{
    return q.front == q.rear ? NULL : q.a[q.front + 1];
}

char *PeekRear(struct DEQueue q)
{
    return q.front == q.rear ? NULL : q.a[q.rear];
}

int IsEmpty(struct DEQueue q)
{
    return q.front == q.rear ? 1 : 0;
}

int IsFull(struct DEQueue q)
{
    return q.rear == q.size - 1 && q.front == -1 ? 1 : 0;
}

void Display(struct DEQueue q)
{
    if (q.front == q.rear)
        printf("DEQueue is Empty\n");
    else
    {
        int i = q.front + 1;
        printf("DEQueue : ");
        while (i <= q.rear)
            printf("%s ", q.a[i++]);
        printf("\n");
    }
}

void Destroy(struct DEQueue *q)
{
    char *temp;
    int i = 0;
    while (i < q->size)
    {
        temp = q->a[++q->front];
        free(temp);
        i++;
    }
    q->front = q->rear = -1;
    free(q->a);
    q->a = NULL;
}

int main()
{
    struct DEQueue q;
    create(&q, 5);
    InsertRear(&q, "Hello", strlen("Hello"));
    InsertRear(&q, "my", strlen("my"));
    InsertRear(&q, "name", strlen("name"));
    InsertFront(&q, "is", strlen("is"));
    InsertFront(&q, "you", strlen("you"));
    Display(q);

    printf("Is DEQueue Empty : %d\n", IsEmpty(q));
    printf("Is DEQueue Full : %d\n", IsFull(q));
    printf("Front value : %s\n", PeekFront(q));
    printf("Rear value : %s\n", PeekRear(q));
    DeleteRear(&q);
    DeleteFront(&q);
    Display(q);

    // Destroy(&q);
    // DeleteRear(&q);
    return 0;
}
          </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
DEQueue is Full at Start
DEQueue is Full at Start
DEQueue : Hello my name
Is DEQueue Empty : 0
Is DEQueue Full : 0
Front value : Hello
Rear value : name
Deleted Rear value : name
Deleted Front value : Hello
DEQueue : my
                                          </pre
              >
            </div>
          </div>
        </div>

        <div id="queue11" class="Content-box">
          <h3>
            11. Implement the operations of priority queue dynamically of
            integers (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct Node
{
    int data;
    int priority;
    struct Node *next;
};

struct PriorityQueue
{
    struct Node *head;
};

void initQueue(struct PriorityQueue *pq)
{
    pq->head = NULL;
}

int isEmpty(struct PriorityQueue *pq)
{
    return pq->head == NULL;
}

int isFull()
{
    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));
    if (temp == NULL)
    {
        return 1;
    }
    free(temp);
    return 0;
}

void insert(struct PriorityQueue *pq, int value, int priority)
{
    if (isFull())
    {
        printf("Priority Queue is Full\n");
        return;
    }

    struct Node *newNode = (struct Node *)malloc(sizeof(struct 
    Node));
    newNode->data = value;
    newNode->priority = priority;
    newNode->next = NULL;

    if (pq->head == NULL || pq->head->priority > priority)
    {
        newNode->next = pq->head;
        pq->head = newNode;
    }
    else
    {
        struct Node *current = pq->head;
        while (current->next != NULL && current->next->priority <= 
        priority)
        {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }

    printf("Inserted %d with priority %d into the priority 
    queue\n", value, priority);
}

void delete(struct PriorityQueue *pq)
{
    if (isEmpty(pq))
    {
        printf("Priority Queue is Empty\n");
        return;
    }

    struct Node *temp = pq->head;
    pq->head = pq->head->next;
    printf("Deleted %d with priority %d from the priority queue\n", 
    temp->data, temp->priority);
    free(temp);
}

void peek(struct PriorityQueue *pq)
{
    if (isEmpty(pq))
    {
        printf("Priority Queue is Empty\n");
    }
    else
    {
        printf("Highest Priority Element: %d with priority %d\n", 
        
        pq->head->data, pq->head->priority);
    }
}

int main()
{
    struct PriorityQueue pq;
    initQueue(&pq);

    int choice, value, priority;

    while (1)
    {
        printf("\n1. Insert\n2. Delete\n3. Peek\n4. IsEmpty\n5. 
        IsFull\n6. Exit\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            printf("Enter the value to insert: ");
            scanf("%d", &value);
            printf("Enter the priority of the value: ");
            scanf("%d", &priority);
            insert(&pq, value, priority);
            break;
        case 2:
            delete (&pq);
            break;
        case 3:
            peek(&pq);
            break;
        case 4:
            printf(isEmpty(&pq) ? "Priority Queue is Empty\n" : 
            "Priority Queue is Not Empty\n");
            break;
        case 5:
            printf(isFull() ? "Priority Queue is Full\n" : 
            "Priority Queue is Not Full\n");
            break;
        case 6:
            return 0;
        default:
            printf("Invalid option. Please try again.\n");
            break;
        }
    }

    return 0;
}

          </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
1. Insert
2. Delete
3. Peek
4. IsEmpty
5. IsFull
6. Exit
Enter your choice: 1
Enter the value to insert: 10
Enter the priority of the value: 2
Inserted 10 with priority 2 into the 
priority queue

1. Insert
2. Delete
3. Peek
4. IsEmpty
5. IsFull
6. Exit
Enter your choice: 1
Enter the value to insert: 20
Enter the priority of the value: 1
Inserted 20 with priority 1 into the 
priority queue

1. Insert
2. Delete
3. Peek
4. IsEmpty
5. IsFull
6. Exit
Enter your choice: 2
Deleted 20 with priority 1 from the 
priority queue
                                          </pre
              >
            </div>
          </div>
        </div>

        <div id="queue12" class="Content-box">
          <h3>
            12. Implement the operations of priority queue dynamically of string
            (insert, delete, peek, isEmpty, isFull).
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct Node
{
    char data;
    int priority;
    struct Node *next;
};

struct PriorityQueue
{
    struct Node *head;
};

void initQueue(struct PriorityQueue *pq)
{
    pq->head = NULL;
}

int isEmpty(struct PriorityQueue *pq)
{
    return pq->head == NULL;
}

int isFull()
{
    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));
    if (temp == NULL)
    {
        return 1;
    }
    free(temp);
    return 0;
}

void insert(struct PriorityQueue *pq, char value, int priority)
{
    if (isFull())
    {
        printf("Priority Queue is Full\n");
        return;
    }

    struct Node *newNode = (struct Node *)malloc(sizeof(struct 
    Node));
    newNode->data = value;
    newNode->priority = priority;
    newNode->next = NULL;

    if (pq->head == NULL || pq->head->priority > priority)
    {
        newNode->next = pq->head;
        pq->head = newNode;
    }
    else
    {
        struct Node *current = pq->head;
        while (current->next != NULL && current->next->priority <= 
        priority)
        {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }

    printf("Inserted '%c' with priority %d into the priority 
    queue\n", value, priority);
}

void delete(struct PriorityQueue *pq)
{
    if (isEmpty(pq))
    {
        printf("Priority Queue is Empty\n");
        return;
    }

    struct Node *temp = pq->head;
    pq->head = pq->head->next;
    printf("Deleted '%c' with priority %d from the priority 
    queue\n", temp->data, temp->priority);
    free(temp);
}

void peek(struct PriorityQueue *pq)
{
    if (isEmpty(pq))
    {
        printf("Priority Queue is Empty\n");
    }
    else
    {
        printf("Highest Priority Element: '%c' with priority %d\n", 
        pq->head->data, pq->head->priority);
    }
}

int main()
{
    struct PriorityQueue pq;
    initQueue(&pq);

    int choice, priority;
    char value;

    while (1)
    {
        printf("\n1. Insert\n2. Delete\n3. Peek\n4. IsEmpty\n5. 
        IsFull\n6. Exit\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            printf("Enter the character to insert: ");
            scanf(" %c", &value);
            printf("Enter the priority of the character: ");
            scanf("%d", &priority);
            insert(&pq, value, priority);
            break;
        case 2:
            delete (&pq);
            break;
        case 3:
            peek(&pq);
            break;
        case 4:
            printf(isEmpty(&pq) ? "Priority Queue is Empty\n" : 
            "Priority Queue is Not Empty\n");
            break;
        case 5:
            printf(isFull() ? "Priority Queue is Full\n" : 
            "Priority Queue is Not Full\n");
            break;
        case 6:
            return 0;
        default:
            printf("Invalid option. Please try again.\n");
            break;
        }
    }

    return 0;
}

          </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
1. Insert
2. Delete
3. Peek
4. IsEmpty
5. IsFull
6. Exit
Enter your choice: 1
Enter the character to insert: A
Enter the priority of the character: 3
Inserted 'A' with priority 3 into the
 priority queue

1. Insert
2. Delete
3. Peek
4. IsEmpty
5. IsFull
6. Exit
Enter your choice: 1
Enter the character to insert: B
Enter the priority of the character: 1
Inserted 'B' with priority 1 into the 
priority queue

1. Insert
2. Delete
3. Peek
4. IsEmpty
5. IsFull
6. Exit
Enter your choice: 2
Deleted 'B' with priority 1 from the
 priority queue

                                          </pre
              >
            </div>
          </div>
        </div>

        <div id="queue13" class="Content-box">
          <h3>
            13. Find the first circular tour that visits all petrol pumps.
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>

int circularTour(int arr[][2], int n)
{
    int total_petrol = 0, total_distance = 0;
    int current_petrol = 0, start_index = 0;

    for (int i = 0; i < n; i++)
    {
        total_petrol += arr[i][0];
        total_distance += arr[i][1];
        current_petrol += arr[i][0] - arr[i][1];

        if (current_petrol < 0)
        {
            start_index = i + 1;
            current_petrol = 0;
        }
    }

    if (total_petrol < total_distance)
    {
        return -1;
    }

    return start_index;
}

int main()
{
    int arr1[][2] = {{4, 6}, {6, 5}, {7, 3}, {4, 5}};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    int result1 = circularTour(arr1, n1);
    printf("Starting index for first tour in arr1: %d\n", result1);

    int arr2[][2] = {{6, 4}, {3, 6}, {7, 3}};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int result2 = circularTour(arr2, n2);
    printf("Starting index for first tour in arr2: %d\n", result2);

    return 0;
}

          </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Starting index for first tour in arr1: 1
Starting index for first tour in arr2: 2

                                          </pre
              >
            </div>
          </div>
        </div>

        <div id="queue14" class="Content-box">
          <h3>14. Length of the longest valid substring.</h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;string.h>


int longestValidParentheses(char *s)
{
    int maxLength = 0;
    int stack[10000];  
    int top = -1;      
    stack[++top] = -1; 

    for (int i = 0; i < strlen(s); i++)
    {
        if (s[i] == '(')
        {
            stack[++top] = i; stack
        }
        else
        {         
            top--; 

            if (top == -1)
            {
                stack[++top] = i; 
            }
            else
            {
                
                maxLength = (maxLength > (i - stack[top])) ? 
                maxLength : (i - stack[top]);
            }
        }
    }
    return maxLength;
}

int main()
{
    char str[10000]; 
    printf("Enter the string of parentheses: ");
    scanf("%s", str);

    int result = longestValidParentheses(str);
    printf("Length of the longest valid substring: %d\n", result);

    return 0;
}
 
          </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter the string of parentheses: (()())
Length of the longest valid substring: 6
  
                                          </pre
              >
            </div>
          </div>
        </div>

        <div id="queue15" class="Content-box">
          <h3>15. Find the next greater element.</h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

void findNextGreaterElement(int arr[], int n)
{
    int *result = (int *)malloc(n * sizeof(int));
    int *stack = (int *)malloc(n * sizeof(int));
    int top = -1;

    for (int i = 0; i < n; i++)
    {
        result[i] = -1;
    }

    for (int i = 0; i < n; i++)
    {
        while (top != -1 && arr[i] > arr[stack[top]])
        {
            result[stack[top]] = arr[i];
            top--;
        }
        stack[++top] = i;
    }

    free(stack);

    for (int i = 0; i < n; i++)
    {
        printf("%d ", result[i]);
    }
    printf("\n");

    free(result);
}

int main()
{
    int n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int *arr = (int *)malloc(n * sizeof(int));
    printf("Enter the elements of the array: ");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    findNextGreaterElement(arr, n);

    free(arr);
    return 0;
}

          </pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter the size of the array: 5
Enter the elements of the array: 4 5 2 10 8
5 10 10 -1 -1
                                          </pre
              >
            </div>
          </div>
        </div>

        <div id="queue16" class="Content-box">
          <h3>16. Find next smaller element.</h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct
{
    int *data;
    int top;
} Stack;

Stack *createStack(int capacity)
{
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    stack->top = -1;
    stack->data = (int *)malloc(capacity * sizeof(int));
    return stack;
}

int isEmpty(Stack *stack)
{
    return stack->top == -1;
}

void push(Stack *stack, int value)
{
    stack->data[++stack->top] = value;
}

int pop(Stack *stack)
{
    return stack->data[stack->top--];
}

void findNextSmallerElement(int arr[], int n)
{
    int *result = (int *)malloc(n * sizeof(int));
    Stack *stack = createStack(n);

    for (int i = 0; i < n; i++)
    {
        result[i] = -1;
    }

    for (int i = 0; i < n; i++)
    {
        while (!isEmpty(stack) && arr[i] < arr[stack->data
        [stack->top]])
        {
            int index = pop(stack);
            result[index] = arr[i];
        }
        push(stack, i);
    }

    for (int i = 0; i < n; i++)
    {
        printf("%d ", result[i]);
    }
    printf("\n");

    free(result);
    free(stack->data);
    free(stack);
}

int main()
{
    int n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int *arr = (int *)malloc(n * sizeof(int));
    printf("Enter the elements of the array: ");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    findNextSmallerElement(arr, n);

    free(arr);
    return 0;
}

              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter the size of the array: 5
Enter the elements of the array: 4 3 2 1 5
3 2 1 -1 -1
              </pre>
            </div>
          </div>
        </div>

        <div id="queue17" class="Content-box">
          <h3>
            17. Queue based approach for first non-repeating character in a
            stream.
          </h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

#define MAX_CHAR 256

typedef struct
{
    char *data;
    int front;
    int rear;
    int capacity;
} Queue;

Queue *createQueue(int capacity)
{
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = 0;
    queue->rear = -1;
    queue->data = (char *)malloc(capacity * sizeof(char));
    return queue;
}

int isQueueEmpty(Queue *queue)
{
    return queue->front > queue->rear;
}

void enqueue(Queue *queue, char value)
{
    queue->data[++queue->rear] = value;
}

char dequeue(Queue *queue)
{
    return queue->data[queue->front++];
}

void firstNonRepeatingCharacter(char *stream)
{
    int frequency[MAX_CHAR] = {0};
    int i = 0;

    Queue *queue = createQueue(strlen(stream));

    while (stream[i] != '\0')
    {
        char current = stream[i];
        frequency[current]++;
        enqueue(queue, current);

        while (!isQueueEmpty(queue) && frequency[queue->data
        [queue->front]] > 1)
        {
            dequeue(queue);
        }

        if (isQueueEmpty(queue))
        {
            printf("-1 ");
        }
        else
        {
            printf("%c ", queue->data[queue->front]);
        }
        i++;
    }

    free(queue->data);
    free(queue);
}

int main()
{
    char stream[100];
    printf("Enter the character stream: ");
    scanf("%s", stream);

    firstNonRepeatingCharacter(stream);
    printf("\n");

    return 0;
}

              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter the character stream: aabcc
a -1 c 
              </pre>
            </div>
          </div>
        </div>

        <div id="queue18" class="Content-box">
          <h3>18. Reverse first K elements of queue.</h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX 100

typedef struct
{
    int items[MAX];
    int front;
    int rear;
} Queue;

Queue *createQueue()
{
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

int isEmpty(Queue *q)
{
    return q->front == -1;
}

int isFull(Queue *q)
{
    return q->rear == MAX - 1;
}

void enqueue(Queue *q, int value)
{
    if (isFull(q))
    {
        printf("Queue is full!\n");
        return;
    }
    if (isEmpty(q))
    {
        q->front = 0;
    }
    q->rear++;
    q->items[q->rear] = value;
}

int dequeue(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty!\n");
        return -1;
    }
    int item = q->items[q->front];
    q->front++;
    if (q->front > q->rear)
    {
        q->front = q->rear = -1;
    }
    return item;
}

void reverseFirstK(Queue *q, int K)
{
    if (isEmpty(q) || K <= 0 || K > (q->rear - q->front + 1))
    {
        return;
    }

    int stack[MAX];
    int top = -1;

    for (int i = 0; i < K; i++)
    {
        stack[++top] = dequeue(q);
    }

    for (int i = 0; i < K; i++)
    {
        enqueue(q, stack[top--]);
    }

    for (int i = 0; i < (q->rear - q->front + 1) - K; i++)
    {
        enqueue(q, dequeue(q));
    }
}

void printQueue(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty!\n");
        return;
    }
    for (int i = q->front; i <= q->rear; i++)
    {
        printf("%d ", q->items[i]);
    }
    printf("\n");
}

int main()
{
    Queue *q = createQueue();
    int n, k, value;

    printf("Enter the number of elements in the queue: ");
    scanf("%d", &n);
    printf("Enter the elements: ");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &value);
        enqueue(q, value);
    }

    printf("Enter the value of K: ");
    scanf("%d", &k);

    reverseFirstK(q, k);

    printf("Queue after reversing first %d elements: ", k);
    printQueue(q);

    free(q);

    return 0;
}

              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter the number of elements in the 
queue: 6
Enter the elements: 10 20 30 40 50 60
Enter the value of K: 3
Queue after reversing first 3 elements
: 30 20 10 40 50 60
              </pre>
            </div>
          </div>
        </div>

        <div id="queue19" class="Content-box">
          <h3>19. Queue reversal.</h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX 100

typedef struct
{
    int items[MAX];
    int front;
    int rear;
} Queue;

Queue *createQueue()
{
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

int isEmpty(Queue *q)
{
    return q->front == -1;
}

int isFull(Queue *q)
{
    return q->rear == MAX - 1;
}

void enqueue(Queue *q, int value)
{
    if (isFull(q))
    {
        printf("Queue is full!\n");
        return;
    }
    if (isEmpty(q))
    {
        q->front = 0;
    }
    q->rear++;
    q->items[q->rear] = value;
}

int dequeue(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty!\n");
        return -1;
    }
    int item = q->items[q->front];
    q->front++;
    if (q->front > q->rear)
    {
        q->front = q->rear = -1;
    }
    return item;
}

void reverseQueue(Queue *q)
{
    if (isEmpty(q))
    {
        return;
    }

    int stack[MAX];
    int top = -1;

    while (!isEmpty(q))
    {
        stack[++top] = dequeue(q);
    }

    while (top != -1)
    {
        enqueue(q, stack[top--]);
    }
}

void printQueue(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty!\n");
        return;
    }
    for (int i = q->front; i <= q->rear; i++)
    {
        printf("%d ", q->items[i]);
    }
    printf("\n");
}

int main()
{
    Queue *q = createQueue();
    int n, value;

    printf("Enter the number of elements in the queue: ");
    scanf("%d", &n);
    printf("Enter the elements: ");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &value);
        enqueue(q, value);
    }

    printf("Queue before reversing: ");
    printQueue(q);

    reverseQueue(q);

    printf("Queue after reversing: ");
    printQueue(q);

    free(q);

    return 0;
}
</pre
              >
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter the number of elements in the queue: 5
Enter the elements: 1 2 3 4 5
Queue before reversing: 1 2 3 4 5 
Queue after reversing: 5 4 3 2 1 
              </pre>
            </div>
          </div>
        </div>

        <div id="queue20" class="Content-box">
          <h3>20. Rotten oranges.</h3>
          <div class="code-box">
            <div class="code">
              <h4>Code :</h4>
              <pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX 100

typedef struct
{
    int x[MAX * MAX];
    int y[MAX * MAX];
    int front;
    int rear;
} Queue;

Queue *createQueue()
{
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->front = 0;
    q->rear = 0;
    return q;
}

void enqueue(Queue *q, int x, int y)
{
    q->x[q->rear] = x;
    q->y[q->rear] = y;
    q->rear++;
}

void dequeue(Queue *q, int *x, int *y)
{
    *x = q->x[q->front];
    *y = q->y[q->front];
    q->front++;
}

int isEmpty(Queue *q)
{
    return q->front == q->rear;
}

int orangesRotting(int grid[MAX][MAX], int n, int m)
{
    Queue *q = createQueue();
    int freshOranges = 0;
    int time = -1;

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (grid[i][j] == 2)
            {
                enqueue(q, i, j);
            }
            else if (grid[i][j] == 1)
            {
                freshOranges++;
            }
        }
    }

    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    while (!isEmpty(q))
    {
        int size = q->rear - q->front;
        time++;

        for (int i = 0; i < size; i++)
        {
            int x, y;
            dequeue(q, &x, &y);

            for (int d = 0; d < 4; d++)
            {
                int newX = x + directions[d][0];
                int newY = y + directions[d][1];

                if (newX >= 0 && newX < n && newY >= 0 
                && newY < m && grid[newX][newY] == 1)
                {
                    grid[newX][newY] = 2;
                    freshOranges--;
                    enqueue(q, newX, newY);
                }
            }
        }
    }

    return freshOranges == 0 ? time : -1;
}

int main()
{
    int grid[MAX][MAX];
    int n, m;

    printf("Enter dimensions of grid (n m): ");
    scanf("%d %d", &n, &m);

    printf("Enter the grid values (0 for empty, 1 for 
    fresh orange, 2 for rotten orange):\n");
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf("%d", &grid[i][j]);
        }
    }

    int result = orangesRotting(grid, n, m);
    printf("The earliest time after which all 
    oranges are rotten: %d\n", result);

    return 0;
}

              </pre>
            </div>
            <div class="output">
              <h4>Output :</h4>
              <pre>
Enter dimensions of grid (n m): 3 3
Enter the grid values (0 for empty, 
1 for fresh orange, 2 for rotten orange):
2 1 1
1 0 2
1 1 2
The earliest time after which all oranges are rotten: 2
              </pre>
            </div>
          </div>
        </div>

        <footer id="Contact">
          <img src="../Images/profile.jpg" />
          <p>Learn Code</p>
          <span>Copywrite &copy; 2024 LearnCode.com </span>

          <a
            href="https://www.facebook.com/"
            aria-label="facebook"
            target="_blank"
            rel="noreferrer"
            class="links"
            ><svg
              fill="currentColor"
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              class="w-5 h-5"
              viewBox="0 0 24 24"
            >
              <path
                d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"
              ></path>
            </svg>
          </a>

          <a
            href="https://www.twitter.com/"
            aria-label="twitter"
            target="_blank"
            rel="noreferrer"
            class="links"
          >
            <svg
              fill="currentColor"
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              class="w-5 h-5"
              viewBox="0 0 24 24"
            >
              <path
                d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"
              ></path>
            </svg>
          </a>

          <a
            href="https://www.instagram.com/"
            aria-label="instagram"
            target="_blank"
            rel="noreferrer"
            class="links"
            ><svg
              fill="none"
              stroke="currentColor"
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              class="w-5 h-5"
              viewBox="0 0 24 24"
            >
              <rect width="20" height="20" x="2" y="2" rx="5" ry="5"></rect>
              <path
                d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37zm1.5-4.87h.01"
              ></path>
            </svg>
          </a>

          <a
            href="https://www.github.com/"
            aria-label="github"
            target="_blank"
            rel="noreferrer"
            class="links"
            ><svg
              stroke="currentColor"
              fill="currentColor"
              stroke-width="0"
              viewBox="0 0 1024 1024"
              class="text-xl"
              height="1em"
              width="1em"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"
              ></path>
            </svg>
          </a>
        </footer>
      </section>
    </main>
  </body>
</html>
